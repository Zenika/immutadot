<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>path/toPath.js - Documentation</title>

    <!--[if lt IE 9]>
        <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/main.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="nav">
    <h2 class="home-link"><a href="index.html">immutad‚óèt</a></h2><h3>Namespaces</h3><ul><li><details open><summary><a href="array.html">array</a></summary><ul class='methods'><li data-type='method'><a href="array.html#.concat">concat</a></li><li data-type='method'><a href="array.html#.fill">fill</a></li><li data-type='method'><a href="array.html#.filter">filter</a></li><li data-type='method'><a href="array.html#.map">map</a></li><li data-type='method'><a href="array.html#.pop">pop</a></li><li data-type='method'><a href="array.html#.push">push</a></li><li data-type='method'><a href="array.html#.reverse">reverse</a></li><li data-type='method'><a href="array.html#.shift">shift</a></li><li data-type='method'><a href="array.html#.slice">slice</a></li><li data-type='method'><a href="array.html#.sort">sort</a></li><li data-type='method'><a href="array.html#.splice">splice</a></li><li data-type='method'><a href="array.html#.unshift">unshift</a></li></ul></details></li><li><details open><summary><a href="core.html">core</a></summary><ul class='methods'><li data-type='method'><a href="core.html#.convert">convert</a></li><li data-type='method'><a href="core.html#.get">get</a></li><li data-type='method'><a href="core.html#.set">set</a></li><li data-type='method'><a href="core.html#.unset">unset</a></li><li data-type='method'><a href="core.html#.update">update</a></li></ul></details></li><li><details open><summary><a href="flow.html">flow</a></summary><ul class='methods'><li data-type='method'><a href="flow.html#.flow">flow</a></li></ul></details></li><li><details open><summary><a href="lang.html">lang</a></summary><ul class='methods'><li data-type='method'><a href="lang.html#.add">add</a></li><li data-type='method'><a href="lang.html#.divide">divide</a></li><li data-type='method'><a href="lang.html#.multiply">multiply</a></li><li data-type='method'><a href="lang.html#.subtract">subtract</a></li><li data-type='method'><a href="lang.html#.toggle">toggle</a></li></ul></details></li><li><details open><summary><a href="object.html">object</a></summary><ul class='methods'><li data-type='method'><a href="object.html#.assign">assign</a></li></ul></details></li><li><details open><summary><a href="path.html">path</a></summary><ul class='methods'><li data-type='method'><a href="path.html#.toPath">toPath</a></li></ul></details></li><li><details open><summary><a href="string.html">string</a></summary><ul class='methods'><li data-type='method'><a href="string.html#.concat">concat</a></li><li data-type='method'><a href="string.html#.padEnd">padEnd</a></li><li data-type='method'><a href="string.html#.padStart">padStart</a></li><li data-type='method'><a href="string.html#.replace">replace</a></li><li data-type='method'><a href="string.html#.slice">slice</a></li><li data-type='method'><a href="string.html#.substr">substr</a></li><li data-type='method'><a href="string.html#.substring">substring</a></li><li data-type='method'><a href="string.html#.toLocaleLowerCase">toLocaleLowerCase</a></li><li data-type='method'><a href="string.html#.toLocaleUpperCase">toLocaleUpperCase</a></li><li data-type='method'><a href="string.html#.toLowerCase">toLowerCase</a></li><li data-type='method'><a href="string.html#.toUpperCase">toUpperCase</a></li><li data-type='method'><a href="string.html#.trim">trim</a></li><li data-type='method'><a href="string.html#.trimLeft">trimLeft</a></li><li data-type='method'><a href="string.html#.trimRight">trimRight</a></li></ul></details></li></ul>
</nav>

<div id="main" class="main-container">
    
        <h1 class="page-title">path/toPath.js</h1>
    

    



    
    <section>
        <article>
            <pre class="source linenums"><code><ol class="lines"><li id="line1" class="line"><span class="hljs-keyword">import</span> {</li><li id="line2" class="line">  allProps,</li><li id="line3" class="line">  index,</li><li id="line4" class="line">  list,</li><li id="line5" class="line">  prop,</li><li id="line6" class="line">  slice,</li><li id="line7" class="line">} <span class="hljs-keyword">from</span> <span class="hljs-string">'./consts'</span></li><li id="line8" class="line"></li><li id="line9" class="line"><span class="hljs-keyword">import</span> {</li><li id="line10" class="line">  filter,</li><li id="line11" class="line">  map,</li><li id="line12" class="line">  race,</li><li id="line13" class="line">  regexp,</li><li id="line14" class="line">} <span class="hljs-keyword">from</span> <span class="hljs-string">'./parser.utils'</span></li><li id="line15" class="line"></li><li id="line16" class="line"><span class="hljs-keyword">import</span> {</li><li id="line17" class="line">  isIndex,</li><li id="line18" class="line">  isSliceIndex,</li><li id="line19" class="line">} <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span></li><li id="line20" class="line"></li><li id="line21" class="line"><span class="hljs-keyword">import</span> {</li><li id="line22" class="line">  isNil,</li><li id="line23" class="line">  toString,</li><li id="line24" class="line">} <span class="hljs-keyword">from</span> <span class="hljs-string">'util/lang'</span></li><li id="line25" class="line"></li><li id="line26" class="line"><span class="hljs-comment">/**</span></li><li id="line27" class="line"><span class="hljs-comment"> * Strip slashes preceding occurences of &lt;code&gt;quote&lt;/code&gt; from &lt;code&gt;str&lt;/code&gt;&lt;br /&gt;</span></li><li id="line28" class="line"><span class="hljs-comment"> * Possible quotes are &lt;code&gt;"&lt;/code&gt; and &lt;code&gt;'&lt;/code&gt;.</span></li><li id="line29" class="line"><span class="hljs-comment"> * @function</span></li><li id="line30" class="line"><span class="hljs-comment"> * @param {string} str The string</span></li><li id="line31" class="line"><span class="hljs-comment"> * @param {string} quote The quote to unescape</span></li><li id="line32" class="line"><span class="hljs-comment"> * @returns {string} The unescaped string</span></li><li id="line33" class="line"><span class="hljs-comment"> * @memberof path</span></li><li id="line34" class="line"><span class="hljs-comment"> * @private</span></li><li id="line35" class="line"><span class="hljs-comment"> * @since 1.0.0</span></li><li id="line36" class="line"><span class="hljs-comment"> */</span></li><li id="line37" class="line"><span class="hljs-keyword">const</span> unescapeQuotes = <span class="hljs-function">(<span class="hljs-params">str, quote</span>) =&gt;</span> str.replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`\\\\<span class="hljs-subst">${quote}</span>`</span>, <span class="hljs-string">'g'</span>), quote)</li><li id="line38" class="line"></li><li id="line39" class="line"><span class="hljs-comment">/**</span></li><li id="line40" class="line"><span class="hljs-comment"> * Converts &lt;code&gt;str&lt;/code&gt; to a slice index.</span></li><li id="line41" class="line"><span class="hljs-comment"> * @function</span></li><li id="line42" class="line"><span class="hljs-comment"> * @param {string} str The string to convert</span></li><li id="line43" class="line"><span class="hljs-comment"> * @param {number?} defaultValue The default value if &lt;code&gt;str&lt;/code&gt; is empty</span></li><li id="line44" class="line"><span class="hljs-comment"> * @returns {number} &lt;code&gt;undefined&lt;/code&gt; if &lt;code&gt;str&lt;/code&gt; is empty, otherwise an int (may be NaN)</span></li><li id="line45" class="line"><span class="hljs-comment"> * @memberof path</span></li><li id="line46" class="line"><span class="hljs-comment"> * @private</span></li><li id="line47" class="line"><span class="hljs-comment"> * @since 1.0.0</span></li><li id="line48" class="line"><span class="hljs-comment"> */</span></li><li id="line49" class="line"><span class="hljs-keyword">const</span> toSliceIndex = <span class="hljs-function">(<span class="hljs-params">str, defaultValue</span>) =&gt;</span> str === <span class="hljs-string">''</span> ? defaultValue : <span class="hljs-built_in">Number</span>(str)</li><li id="line50" class="line"></li><li id="line51" class="line"><span class="hljs-comment">/**</span></li><li id="line52" class="line"><span class="hljs-comment"> * Tests whether &lt;code&gt;arg&lt;/code&gt; is a valid slice index once converted to a number.</span></li><li id="line53" class="line"><span class="hljs-comment"> * @function</span></li><li id="line54" class="line"><span class="hljs-comment"> * @memberof path</span></li><li id="line55" class="line"><span class="hljs-comment"> * @param {*} arg The value to test</span></li><li id="line56" class="line"><span class="hljs-comment"> * @returns {boolean} True if &lt;code&gt;arg&lt;/code&gt; is a valid slice index once converted to a number, false otherwise.</span></li><li id="line57" class="line"><span class="hljs-comment"> * @private</span></li><li id="line58" class="line"><span class="hljs-comment"> * @since 1.0.0</span></li><li id="line59" class="line"><span class="hljs-comment"> */</span></li><li id="line60" class="line"><span class="hljs-keyword">const</span> isSliceIndexString = <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> isSliceIndex(arg ? <span class="hljs-built_in">Number</span>(arg) : <span class="hljs-literal">undefined</span>)</li><li id="line61" class="line"></li><li id="line62" class="line"><span class="hljs-comment">/**</span></li><li id="line63" class="line"><span class="hljs-comment"> * Wraps &lt;code&gt;fn&lt;/code&gt; allowing to call it with an array instead of a string.&lt;br /&gt;</span></li><li id="line64" class="line"><span class="hljs-comment"> * The returned function behaviour is :&lt;br /&gt;</span></li><li id="line65" class="line"><span class="hljs-comment"> *  - If called with an array, returns a copy of the array with values converted to path keys&lt;br /&gt;</span></li><li id="line66" class="line"><span class="hljs-comment"> *  - Otherwise, calls &lt;code&gt;fn&lt;/code&gt; with the string representation of its argument</span></li><li id="line67" class="line"><span class="hljs-comment"> * @function</span></li><li id="line68" class="line"><span class="hljs-comment"> * @param {function} fn The function to wrap</span></li><li id="line69" class="line"><span class="hljs-comment"> * @returns {function} The wrapper function</span></li><li id="line70" class="line"><span class="hljs-comment"> * @memberof path</span></li><li id="line71" class="line"><span class="hljs-comment"> * @private</span></li><li id="line72" class="line"><span class="hljs-comment"> * @since 1.0.0</span></li><li id="line73" class="line"><span class="hljs-comment"> */</span></li><li id="line74" class="line"><span class="hljs-keyword">const</span> allowingArrays = <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> arg =&gt; {</li><li id="line75" class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arg)) <span class="hljs-keyword">return</span> arg</li><li id="line76" class="line">  <span class="hljs-keyword">return</span> fn(arg)</li><li id="line77" class="line">}</li><li id="line78" class="line"></li><li id="line79" class="line"><span class="hljs-keyword">const</span> emptyStringParser = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> str.length === <span class="hljs-number">0</span> ? [] : <span class="hljs-literal">null</span></li><li id="line80" class="line"></li><li id="line81" class="line"><span class="hljs-keyword">const</span> quotedBracketNotationParser = map(</li><li id="line82" class="line">  regexp(<span class="hljs-regexp">/^\[(['"])(.*?[^\\])\1\]?\.?(.*)$/</span>),</li><li id="line83" class="line">  ([quote, property, rest]) =&gt; [[prop, unescapeQuotes(property, quote)], ...stringToPath(rest)],</li><li id="line84" class="line">)</li><li id="line85" class="line"></li><li id="line86" class="line"><span class="hljs-keyword">const</span> incompleteQuotedBracketNotationParser = map(</li><li id="line87" class="line">  regexp(<span class="hljs-regexp">/^(\[["'][^.[{]*)\.?(.*)$/</span>),</li><li id="line88" class="line">  ([beforeNewSegment, rest]) =&gt; [[prop, beforeNewSegment], ...stringToPath(rest)],</li><li id="line89" class="line">)</li><li id="line90" class="line"></li><li id="line91" class="line"><span class="hljs-keyword">const</span> bareBracketNotationParser = map(</li><li id="line92" class="line">  regexp(<span class="hljs-regexp">/^\[([^\]]*)\]\.?(.*)$/</span>),</li><li id="line93" class="line">  ([property, rest]) =&gt; {</li><li id="line94" class="line">    <span class="hljs-keyword">return</span> isIndex(<span class="hljs-built_in">Number</span>(property))</li><li id="line95" class="line">      ? [[index, <span class="hljs-built_in">Number</span>(property)], ...stringToPath(rest)]</li><li id="line96" class="line">      : [[prop, property], ...stringToPath(rest)]</li><li id="line97" class="line">  },</li><li id="line98" class="line">)</li><li id="line99" class="line"></li><li id="line100" class="line"><span class="hljs-keyword">const</span> incompleteBareBracketNotationParser = map(</li><li id="line101" class="line">  regexp(<span class="hljs-regexp">/^(\[[^.[{]*)\.?(.*)$/</span>),</li><li id="line102" class="line">  ([beforeNewSegment, rest]) =&gt; [[prop, beforeNewSegment], ...stringToPath(rest)],</li><li id="line103" class="line">)</li><li id="line104" class="line"></li><li id="line105" class="line"><span class="hljs-keyword">const</span> sliceNotationParser = map(</li><li id="line106" class="line">  filter(</li><li id="line107" class="line">    regexp(<span class="hljs-regexp">/^\[([^:\]]*):([^:\]]*)\]\.?(.*)$/</span>),</li><li id="line108" class="line">    ([sliceStart, sliceEnd]) =&gt; isSliceIndexString(sliceStart) &amp;&amp; isSliceIndexString(sliceEnd),</li><li id="line109" class="line">  ),</li><li id="line110" class="line">  ([sliceStart, sliceEnd, rest]) =&gt; [[slice, [toSliceIndex(sliceStart, <span class="hljs-number">0</span>), toSliceIndex(sliceEnd)]], ...stringToPath(rest)],</li><li id="line111" class="line">)</li><li id="line112" class="line"></li><li id="line113" class="line"><span class="hljs-keyword">const</span> listWildCardParser = map(</li><li id="line114" class="line">  regexp(<span class="hljs-regexp">/^{\*}\.?(.*)$/</span>),</li><li id="line115" class="line">  ([rest]) =&gt; [[allProps], ...stringToPath(rest)],</li><li id="line116" class="line">)</li><li id="line117" class="line"></li><li id="line118" class="line"><span class="hljs-keyword">const</span> listPropRegexp = <span class="hljs-regexp">/^,?((?!["'])([^,]*)|(["'])(.*?[^\\])\3)(.*)/</span></li><li id="line119" class="line"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">extractListProps</span>(<span class="hljs-params">rawProps</span>) </span>{</li><li id="line120" class="line">  <span class="hljs-keyword">if</span> (rawProps.startsWith(<span class="hljs-string">','</span>)) <span class="hljs-keyword">yield</span> <span class="hljs-string">''</span></li><li id="line121" class="line">  <span class="hljs-keyword">let</span> remProps = rawProps</li><li id="line122" class="line">  <span class="hljs-keyword">while</span> (remProps !== <span class="hljs-string">''</span>) {</li><li id="line123" class="line">    <span class="hljs-keyword">const</span> [, , bareProp, , quotedProp, rest] = listPropRegexp.exec(remProps)</li><li id="line124" class="line">    <span class="hljs-keyword">yield</span> bareProp === <span class="hljs-literal">undefined</span> ? quotedProp : bareProp</li><li id="line125" class="line">    remProps = rest</li><li id="line126" class="line">  }</li><li id="line127" class="line">}</li><li id="line128" class="line"></li><li id="line129" class="line"><span class="hljs-keyword">const</span> listNotationParser = map(</li><li id="line130" class="line">  regexp(<span class="hljs-regexp">/^\{(((?!["'])[^,}]*|(["']).*?[^\\]\2)(,((?!["'])[^,}]*|(["']).*?[^\\]\6))*)\}\.?(.*)$/</span>),</li><li id="line131" class="line">  ([rawProps, , , , , , rest]) =&gt; {</li><li id="line132" class="line">    <span class="hljs-keyword">const</span> props = [...extractListProps(rawProps)]</li><li id="line133" class="line">    <span class="hljs-keyword">return</span> props.length === <span class="hljs-number">1</span> ? [[prop, props[<span class="hljs-number">0</span>]], ...stringToPath(rest)] : [[list, props], ...stringToPath(rest)]</li><li id="line134" class="line">  },</li><li id="line135" class="line">)</li><li id="line136" class="line"></li><li id="line137" class="line"><span class="hljs-keyword">const</span> incompleteListNotationParser = map(</li><li id="line138" class="line">  regexp(<span class="hljs-regexp">/^(\{[^.[{]*)\.?(.*)$/</span>),</li><li id="line139" class="line">  ([beforeNewSegment, rest]) =&gt; [[prop, beforeNewSegment], ...stringToPath(rest)],</li><li id="line140" class="line">)</li><li id="line141" class="line"></li><li id="line142" class="line"><span class="hljs-keyword">const</span> pathSegmentEndedByNewSegment = map(</li><li id="line143" class="line">  regexp(<span class="hljs-regexp">/^([^.[{]*)\.?([[{]?.*)$/</span>),</li><li id="line144" class="line">  ([beforeNewSegment, rest]) =&gt; [[prop, beforeNewSegment], ...stringToPath(rest)],</li><li id="line145" class="line">)</li><li id="line146" class="line"></li><li id="line147" class="line"><span class="hljs-keyword">const</span> applyParsers = race([</li><li id="line148" class="line">  emptyStringParser,</li><li id="line149" class="line">  quotedBracketNotationParser,</li><li id="line150" class="line">  incompleteQuotedBracketNotationParser,</li><li id="line151" class="line">  sliceNotationParser,</li><li id="line152" class="line">  bareBracketNotationParser,</li><li id="line153" class="line">  incompleteBareBracketNotationParser,</li><li id="line154" class="line">  listWildCardParser,</li><li id="line155" class="line">  listNotationParser,</li><li id="line156" class="line">  incompleteListNotationParser,</li><li id="line157" class="line">  pathSegmentEndedByNewSegment,</li><li id="line158" class="line">])</li><li id="line159" class="line"></li><li id="line160" class="line"><span class="hljs-comment">/**</span></li><li id="line161" class="line"><span class="hljs-comment"> * Converts &lt;code&gt;arg&lt;/code&gt; to a path represented as an array of keys.</span></li><li id="line162" class="line"><span class="hljs-comment"> * @function</span></li><li id="line163" class="line"><span class="hljs-comment"> * @param {*} arg The value to convert</span></li><li id="line164" class="line"><span class="hljs-comment"> * @returns {Array&lt;string|number|Array&gt;} The path represented as an array of keys</span></li><li id="line165" class="line"><span class="hljs-comment"> * @memberof path</span></li><li id="line166" class="line"><span class="hljs-comment"> * @private</span></li><li id="line167" class="line"><span class="hljs-comment"> * @since 1.0.0</span></li><li id="line168" class="line"><span class="hljs-comment"> */</span></li><li id="line169" class="line"><span class="hljs-keyword">const</span> stringToPath = <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> {</li><li id="line170" class="line">  <span class="hljs-keyword">if</span> (isNil(arg)) <span class="hljs-keyword">return</span> []</li><li id="line171" class="line">  <span class="hljs-keyword">return</span> applyParsers(toString(arg))</li><li id="line172" class="line">}</li><li id="line173" class="line"></li><li id="line174" class="line"><span class="hljs-keyword">const</span> MAX_CACHE_SIZE = <span class="hljs-number">1000</span></li><li id="line175" class="line"><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()</li><li id="line176" class="line"></li><li id="line177" class="line"><span class="hljs-comment">/**</span></li><li id="line178" class="line"><span class="hljs-comment"> * Memoized version of {@link core.stringToPath}.&lt;br /&gt;</span></li><li id="line179" class="line"><span class="hljs-comment"> * The cache has a maximum size of 1000, when overflowing the cache is cleared.</span></li><li id="line180" class="line"><span class="hljs-comment"> * @function</span></li><li id="line181" class="line"><span class="hljs-comment"> * @param {string} str The string to convert</span></li><li id="line182" class="line"><span class="hljs-comment"> * @returns {Array&lt;string|number|Array&gt;} The path represented as an array of keys</span></li><li id="line183" class="line"><span class="hljs-comment"> * @memberof path</span></li><li id="line184" class="line"><span class="hljs-comment"> * @private</span></li><li id="line185" class="line"><span class="hljs-comment"> * @since 1.0.0</span></li><li id="line186" class="line"><span class="hljs-comment"> */</span></li><li id="line187" class="line"><span class="hljs-keyword">const</span> memoizedStringToPath = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> {</li><li id="line188" class="line">  <span class="hljs-keyword">if</span> (cache.has(str)) <span class="hljs-keyword">return</span> cache.get(str)</li><li id="line189" class="line"></li><li id="line190" class="line">  <span class="hljs-keyword">const</span> path = stringToPath(str)</li><li id="line191" class="line"></li><li id="line192" class="line">  <span class="hljs-keyword">if</span> (cache.size === MAX_CACHE_SIZE) cache.clear()</li><li id="line193" class="line">  cache.set(str, path)</li><li id="line194" class="line"></li><li id="line195" class="line">  <span class="hljs-keyword">return</span> path</li><li id="line196" class="line">}</li><li id="line197" class="line"></li><li id="line198" class="line"><span class="hljs-comment">/**</span></li><li id="line199" class="line"><span class="hljs-comment"> * Converts &lt;code&gt;arg&lt;/code&gt; to a path represented as an array of keys.&lt;br /&gt;</span></li><li id="line200" class="line"><span class="hljs-comment"> * &lt;code&gt;arg&lt;/code&gt; may be a string, in which case it will be parsed.&lt;br /&gt;</span></li><li id="line201" class="line"><span class="hljs-comment"> * It may also be an Array, in which case a copy of the array with values converted to path keys will be returned.&lt;br /&gt;</span></li><li id="line202" class="line"><span class="hljs-comment"> * If &lt;code&gt;arg&lt;/code&gt; is neither a string nor an Array, its string representation will be parsed.</span></li><li id="line203" class="line"><span class="hljs-comment"> * @function</span></li><li id="line204" class="line"><span class="hljs-comment"> * @param {string|Array|*} arg The value to convert</span></li><li id="line205" class="line"><span class="hljs-comment"> * @returns {Array&lt;Array&lt;Symbol,...*&gt;&gt;} The path represented as an array of keys</span></li><li id="line206" class="line"><span class="hljs-comment"> * @memberof path</span></li><li id="line207" class="line"><span class="hljs-comment"> * @since 1.0.0</span></li><li id="line208" class="line"><span class="hljs-comment"> * @example toPath('a.b[1]["."][1:-1]') // =&gt; [[prop, 'a'], [prop, 'b'], [index, 1], [prop, '.'], [slice, [1, -1]]]</span></li><li id="line209" class="line"><span class="hljs-comment"> */</span></li><li id="line210" class="line"><span class="hljs-keyword">const</span> toPath = allowingArrays(<span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> [...memoizedStringToPath(arg)])</li><li id="line211" class="line"></li><li id="line212" class="line"><span class="hljs-comment">/**</span></li><li id="line213" class="line"><span class="hljs-comment"> * This method is like {@link core.toPath} except it returns memoized arrays which must not be mutated.</span></li><li id="line214" class="line"><span class="hljs-comment"> * @function</span></li><li id="line215" class="line"><span class="hljs-comment"> * @param {string|Array|*} arg The value to convert</span></li><li id="line216" class="line"><span class="hljs-comment"> * @returns {Array&lt;Array&lt;Symbol,...*&gt;&gt;} The path represented as an array of keys</span></li><li id="line217" class="line"><span class="hljs-comment"> * @memberof path</span></li><li id="line218" class="line"><span class="hljs-comment"> * @since 1.0.0</span></li><li id="line219" class="line"><span class="hljs-comment"> * @private</span></li><li id="line220" class="line"><span class="hljs-comment"> */</span></li><li id="line221" class="line"><span class="hljs-keyword">const</span> unsafeToPath = allowingArrays(memoizedStringToPath)</li><li id="line222" class="line"></li><li id="line223" class="line"><span class="hljs-keyword">export</span> { toPath, unsafeToPath }</li><li id="line224" class="line"></li></ol></code></pre>
        </article>
    </section>





</div>

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script src="scripts/main.js"></script>
</body>
</html>
